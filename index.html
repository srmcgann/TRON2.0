<!DOCTYPE html>
<html>
  <head>
    <style>
      body, html{
        margin: 0;
        height: 100vh;
        background: linear-gradient(-45deg, #333, #000);
        overflow: hidden;
      }
      #c{
        border: 3px solid #fff3;
        position: absolute;
        background: #04f1;
        left: 50%;
        top: 50%;
        border-radius: 10px;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <canvas id=c></canvas>
    <script>
      c = document.querySelector('#c')
      c.width = 1920
      c.height = 1080
      x = c.getContext('2d')
      C = Math.cos
      S = Math.sin
      t = 0
      T = Math.tan
      rsz = window.onresize = () =>{
        let b = document.body
        let margin = 10
        let n
        let d = .5625
        if(b.clientHeight/b.clientWidth > d){
          c.style.width = `${(n=b.clientWidth) - margin*2}px`
          c.style.height = `${n*d - margin*2}px`
        }else{
          c.style.height = `${(n=b.clientHeight) - margin*2}px`
          c.style.width = `${n/d - margin*2}px`
        }
      }

      rsz()

      async function Draw(){
        if(!t){
          buffer        = document.createElement('canvas')
          bctx          = buffer.getContext('2d')
          buffer.width  = c.width
          buffer.height = c.height
          oXv2 = oYv2 = oZv2 = 0
          oX = oY = oZ = 0
          Rl = Pt = Yw = 0
          Rn = Math.random
          R = (Rl,Pt,Yw,m) => {
            let p
            M = Math
            A = M.atan2
            H = M.hypot
            if(m){
              X+=oX
              Y+=oY
              Z+=oZ
            }      
            X = S(p=A(X,Z)+Yw) * (d=H(X,Z))
            Z = C(p)*d
            X = S(p=A(X,Y)+Rl) * (d=H(X,Y))
            Y = C(p) * d
            Y = S(p=A(Y,Z)+Pt) * (d=H(Y,Z))
            Z = C(p)*d
            X += oXv2
            Y += oYv2
            Z += oZv2
            if(m){
              Y += 0
              Z += 4
            }
          }
          
          R2=(Rl,Pt,Yw,m=false)=>{
            M=Math
            A=M.atan2
            H=M.hypot
            if(m){
              X-=oX
              Y-=oY
              Z-=oZ
            }
            X=S(p=A(X,Y)+Rl)*(d=H(X,Y))
            Y=C(p)*d
            Y=S(p=A(Y,Z)+Pt)*(d=H(Y,Z))
            Z=C(p)*d
            X=S(p=A(X,Z)+Yw)*(d=H(X,Z))
            Z=C(p)*d
          }

          Q = () => [c.width/2+X/Z*700, c.height/2+Y/Z*700 + mofy]
          Q2 = () => [c.width/2+X/Z*2400*tscl1 + tmofx * 21.95 - 1920/4 + mofx1, c.height/2+Y/Z*2400*tscl1 + tmofy + mofy1]
          Q3 = () => [c.width/2+X/Z*1200*tscl2/1.33 + tmofx * 21.95 + 1920/4 + mofx2, c.height/2+Y/Z*1200*tscl2/1.33 + tmofy + mofy2]
          Q2p = () => [X/Z*2400*tscl1, Y/Z*2400*tscl1]
          Q3p = () => [X/Z*1200*tscl2/1.33, Y/Z*1200*tscl2/1.33]
          Q4 = () => [c.width-155+X/Z*33.975, c.height-155+Y/Z*33.975]
          I=(A,B,M,D,E,F,G,H)=>(K=((G-E)*(B-F)-(H-F)*(A-E))/(J=(H-F)*(M-A)-(G-E)*(D-B)))>=0&&K<1&&(L=((M-A)*(B-F)-(D-B)*(A-E))/J)>=0&&L<1?[A+K*(M-A),B+K*(D-B)]:0

          Cube = size => {
            for(CB=[],j=6;j--;CB=[...CB,b])for(b=[],i=4;i--;)b=[...b,[(a=[S(p=Math.PI*2/4*i+Math.PI/4),C(p),2**.5/2])[j%3]*(l=j<3?size/2**.5:-size/2**.5),a[(j+1)%3]*l,a[(j+2)%3]*l]]
            return CB
          }
          
          subbed = (subs, size, sphereize, shape) => {
            for(let m=subs; m--;){
              base = shape
              shape = []
              base.map(v=>{
                l = 0
                X1 = v[l][0]
                Y1 = v[l][1]
                Z1 = v[l][2]
                l = 1
                X2 = v[l][0]
                Y2 = v[l][1]
                Z2 = v[l][2]
                l = 2
                X3 = v[l][0]
                Y3 = v[l][1]
                Z3 = v[l][2]
                if(v.length > 3){
                  l = 3
                  X4 = v[l][0]
                  Y4 = v[l][1]
                  Z4 = v[l][2]
                  if(v.length > 4){
                    l = 4
                    X5 = v[l][0]
                    Y5 = v[l][1]
                    Z5 = v[l][2]
                  }
                }
                mx1 = (X1+X2)/2
                my1 = (Y1+Y2)/2
                mz1 = (Z1+Z2)/2
                mx2 = (X2+X3)/2
                my2 = (Y2+Y3)/2
                mz2 = (Z2+Z3)/2
                a = []
                switch(v.length){
                  case 3:
                    mx3 = (X3+X1)/2
                    my3 = (Y3+Y1)/2
                    mz3 = (Z3+Z1)/2
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    break
                  case 4:
                    mx3 = (X3+X4)/2
                    my3 = (Y3+Y4)/2
                    mz3 = (Z3+Z4)/2
                    mx4 = (X4+X1)/2
                    my4 = (Y4+Y1)/2
                    mz4 = (Z4+Z1)/2
                    cx = (X1+X2+X3+X4)/4
                    cy = (Y1+Y2+Y3+Y4)/4
                    cz = (Z1+Z2+Z3+Z4)/4
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx4, Y = my4, Z = mz4, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx1, Y = my1, Z = mz1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx2, Y = my2, Z = mz2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = mx4, Y = my4, Z = mz4, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    X = mx3, Y = my3, Z = mz3, a = [...a, [X,Y,Z]]
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    break
                  case 5:
                    cx = (X1+X2+X3+X4+X5)/5
                    cy = (Y1+Y2+Y3+Y4+Y5)/5
                    cz = (Z1+Z2+Z3+Z4+Z5)/5
                    mx3 = (X3+X4)/2
                    my3 = (Y3+Y4)/2
                    mz3 = (Z3+Z4)/2
                    mx4 = (X4+X5)/2
                    my4 = (Y4+Y5)/2
                    mz4 = (Z4+Z5)/2
                    mx5 = (X5+X1)/2
                    my5 = (Y5+Y1)/2
                    mz5 = (Z5+Z1)/2
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X2, Y = Y2, Z = Z2, a = [...a, [X,Y,Z]]
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X3, Y = Y3, Z = Z3, a = [...a, [X,Y,Z]]
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X4, Y = Y4, Z = Z4, a = [...a, [X,Y,Z]]
                    X = X5, Y = Y5, Z = Z5, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    X = X5, Y = Y5, Z = Z5, a = [...a, [X,Y,Z]]
                    X = X1, Y = Y1, Z = Z1, a = [...a, [X,Y,Z]]
                    X = cx, Y = cy, Z = cz, a = [...a, [X,Y,Z]]
                    shape = [...shape, a]
                    a = []
                    break
                }
              })
            }
            if(sphereize){
              ip1 = sphereize
              ip2 = 1-sphereize
              shape = shape.map(v=>{
                v = v.map(q=>{
                  X = q[0]
                  Y = q[1]
                  Z = q[2]
                  d = Math.hypot(X,Y,Z)
                  X /= d
                  Y /= d
                  Z /= d
                  X *= size/2*ip1 + d*ip2
                  Y *= size/2*ip1 + d*ip2
                  Z *= size/2*ip1 + d*ip2
                  return [X,Y,Z]
                })
                return v
              })
            }
            return shape
          }
          subDividedCube         = (size, subs, sphereize = 0) => subbed(subs, size, sphereize, Cube(size))

          stroke = (scol, fcol, lw, dl, oga=1, ocp=false) => {
            if(scol){
              x.strokeStyle = scol
              if(ocp) x.closePath()
              x.lineWidth = Math.min(200, 50/(1+Z)*lw)
              if(dl){
                x.globalAlpha = .25 * oga
                x.stroke()
                x.lineWidth/=3
              }
              x.globalAlpha = 1*oga
              x.stroke()
            }
            if(fcol){
              x.globalAlpha = 1*oga
              x.fillStyle = fcol
              x.fill()
            }
          }
          
          toggleView = () => {
            view++
            view%=views
          }
          
          checkPath = (player, vx=0, vy=0, vz=0) => {
            let l1, l2, ret = false
            if(player.path.length < 2) return
            player.path.map((q, j)=>{
              if(j > 2) return
              l1 = player.path.length - j
              l2 = player.path.length - j-1
              if(j){
                X1 = player.path[l1][0]
                Y1 = player.path[l1][1]
                Z1 = player.path[l1][2]
              }else{
                X1 = player.X+vx
                Y1 = player.Y+vy
                Z1 = player.Z+vz
              }
              X2 = player.path[l2][0]
              Y2 = player.path[l2][1]
              Z2 = player.path[l2][2]
              if(!ret) players.map((p2, idx) => {
                if(p2.alive && !j || idx != player.id){
                  l2 = p2.path.length-1
                  X3 = p2.path[l2][0]
                  Y3 = p2.path[l2][1]
                  Z3 = p2.path[l2][2]
                  X4 = p2.X
                  Y4 = p2.Y
                  Z4 = p2.Z
                  if(l=I(X1,Z1,X2,Z2,X3,Z3,X4,Z4)){
                    l[2] = idx
                    ret = l
                  }
                }          
                if(!ret){
                  p2.path.map((v, i) => {
                    l1 = i
                    l2 = i-1
                    if((idx != player.id || i!=j) && i && i < p2.path.length-2){
                      X3 = p2.path[l1][0]
                      Y3 = p2.path[l1][1]
                      Z3 = p2.path[l1][2]
                      X4 = p2.path[l2][0]
                      Y4 = p2.path[l2][1]
                      Z4 = p2.path[l2][2]
                      if(l=I(X1,Z1,X2,Z2,X3,Z3,X4,Z4)){
                        l[2] = idx
                        ret = l
                      }
                    }
                  })
                }
              })
              if(!ret) perimeter.map((v, i) => {
                if(i){
                  l1 = i-1
                  l2 = i
                  X3 = perimeter[l1][0]
                  Y3 = perimeter[l1][1]
                  Z3 = perimeter[l1][2]
                  X4 = perimeter[l2][0]
                  Y4 = perimeter[l2][1]
                  Z4 = perimeter[l2][2]
                  if(l=I(X1,Z1,X2,Z2,X3,Z3,X4,Z4)){
                    ret = l
                  }
                }
              })
            })
            return ret
          }
          
          spawnPlayer = (idx=-1) => {
            spawnG = perG * .8
            X     = (Rn()-.5) * spawnG
            Y     = 0
            Z     = (Rn()-.5) * spawnG
            theta = 0
            iPv   = Math.min(playerMaxSpeed, playerMinSpeed * 2)
            if(idx == camSelected){
              oXv = -X
              oYv = 0
              oZv = -Z
              oX  = -X
              oY  = 0
              oZ  = -Z
              Rl  = 0
              Pt  = -.5
              Yw  = 0
              Rlv = 0
              Ptv = -.5
              Ywv = 0
            }
            return {
              X,
              Y,
              Z,
              theta,
              AITimer        : 0,
              score          : typeof players[idx] != 'undefined' ? players[idx].score : 0,
              AITurnTimer    : 0,
              speed          : iPv * 2,
              alive          : true,
              ox             : X,
              oy             : Y,
              oz             : Z,
              path           : [[X,Y,Z], [X,Y,Z]],
              keys           : Array(128).fill(false),
              keyTimers      : Array(128).fill(0),
              name           : typeof players[idx] != 'undefined' ? players[idx].name : (idx == 0 ? 'human' : `AI player ${idx}`),
              respawnPending : false,
              id             : idx == -1 ? players.length : idx
            }
          }

          spawnFlashNotice = (text, col)=>{
            flashNotices = [...flashNotices, [text, col, 2]]
          }
          
          drawLeaderboard = () => {
            margin = 5
            x.globalAlpha = .7
            let w = 400
            let fs = 28
            let h = (2 + players.length) * fs
            x.fillStyle = '#001c'
            x.strokeStyle = '#fff2'
            x.lineWidth = 2
            x.fillRect(margin, c.height-h-margin, w, h)
            x.strokeRect(margin, c.height-h-margin, w, h)
            x.globalAlpha = 1
            
            X2            = 80
            Y2            = 40
            X1            = w - X2 - margin
            Y1            = c.height-h-margin*3
            x.lineWidth   = 10
            x.font        = (40) + 'px monospace'
            x.textAlign   = 'center'
            x.strokeRect(X1, 20 + Y1, X2, Y2)
            x.fillStyle   = `#000`
            x.fillRect(X1, 20 + Y1, X2, Y2)
            str = '[L]'
            x.fillStyle   = `#fff`
            x.fillText(str, X1 + X2/2, Y1 + 50)
            
            x.textAlign = 'left'
            x.font = fs + 'px monospace'
            x.fillStyle = '#0FF'
            x.strokeStyle = '#40F4'
            x.strokeText('LEADERBOARD', margin*2, c.height-margin*2-(players.length+1)*fs+fs/25)
            x.fillText('LEADERBOARD', margin*2, c.height-margin*2-(players.length+1)*fs+fs/25)
            x.fillStyle = '#0F8'
            x.strokeStyle = '#40F4'
            x.strokeText(' # SCORE  NAME', margin*2, c.height-margin*2-players.length*fs+fs/25)
            x.fillText(' # SCORE  NAME', margin*2, c.height-margin*2-players.length*fs+fs/25)
            x.fillStyle = '#fff'
            x.strokeStyle = '#8804'
            scores = []
            players.map((v, idx) => {
              player = players[players.length-idx-1]
              scores = [...scores, {score: player.score, name: player.name}]
            })
            scores.sort((a, b) => a.score-b.score)
            scores.map((player, idx) => {
              str = ` ${scores.length-idx}   ${player.score}    ${player.name}`
              x.strokeText(str, margin*2, c.height-margin*2-idx*fs+fs/25)
              x.fillText(str, margin*2, c.height-margin*2-idx*fs+fs/25)
            })
            x.textAlign = 'center'
          }
          
          drawOverview = () => {
            x.globalAlpha = 1
            margin = 5
            let w = 300
            let h = 300

            x.fillStyle = '#001c'
            x.strokeStyle = '#40fc'
            x.lineWidth = 2
            x.fillRect(c.width-w-margin, c.height-h-margin, w, h)
            x.strokeRect(c.width-w-margin, c.height-h-margin, w, h)

            x.strokeStyle = '#fff3'
            X2            = 80
            Y2            = 40
            X1            = c.width - w - X2 - margin*3
            Y1            = c.height-Y2-margin*6
            x.lineWidth   = 10
            x.font        = (40) + 'px monospace'
            x.textAlign   = 'center'
            x.strokeRect(X1, 20 + Y1, X2, Y2)
            x.fillStyle   = `#000`
            x.fillRect(X1, 20 + Y1, X2, Y2)
            str = '[O]'
            x.fillStyle   = `#fff`
            x.fillText(str, X1 + X2/2, Y1 + 50)

            cond = true
            players.map((player, idx) => {
              if(player.alive){ //&& idx == camSelected){
                X = player.X
                Y = player.Y
                Z = player.Z
                R(0, -Math.PI/2, 0, 0)
                Z = 32
                l = Q4()
                s = Math.min(1e3, 2e3/Z * (.5+S(t*99)*.25))
                x.fillStyle = `hsla(${40+360/players.length*idx + 90},99%,50%,${.1 })`
                x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
                s/=3
                x.fillStyle = `hsla(${360/players.length*idx + 90},99%,50%,${.5})`
                x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
                s/=3
                x.fillStyle = `#fff`
                x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
              }
              player.path = player.path.filter((v, i) => player.path.length < maxPlayerLength|| i)
              x.beginPath()
              player.path.map((q, j) => {
                l1 = j
                X1 = X = player.path[l1][0]
                Y1 = Y = cond ? 0 : player.path[l1][1]
                Z1 = Z = player.path[l1][2]
                if((d1 = Math.hypot(X-players[camSelected].X, Z-players[camSelected].Z)) < 500){
                  R(0, -Math.PI/2, 0, 0)
                  Z = 32
                  if(Z>0) x.lineTo(...Q4())
                }
              })
              col1 = player.alive ? `hsla(${360/players.length*idx + 90},99%,50%,${1})` : '#888'
              col2 = ''
              Z = 50
              stroke(col1, col2, 2, false)
            })
            
            s = .33
            w_ = 160 * s * .9
            h_ = 664 * s * .95
            x.fillStyle = '#000'
            x.fillRect(c.width - w_, c.height - h_ - 316, w_*.9, h_)
            d = players[camSelected].speed / (playerMaxSpeed)
            x.fillStyle = `hsla(${180-180*(d)}, 99%,50%,1)`
            x.fillRect(c.width - w_, c.height - 316, w_*.9, -h_*d)
            w_ = 160 * s
            h_ = 664 * s
            x.strokeStyle = '#fff8'
            x.lineWidth = 4
            x.strokeRect(c.width - w_+4, c.height - h_ - 305, w_-8, h_-10)
            
            x.strokeStyle = `#fff4`
            X2            = 40
            Y2            = 21
            X1            = c.width - X2/2 -28
            Y1            = c.height/2 - 18
            x.lineWidth   = 10
            x.font        = (20) + 'px monospace'
            x.textAlign   = 'center'
            x.strokeRect(X1, Y1, X2, Y2)
            x.fillStyle   = '#000'
            x.fillRect(X1, Y1, X2, Y2)
            str = 'SPD'
            x.fillStyle   = `#fff`
            x.fillText(str, X1 + X2/2, Y1 + 16)
          }
          
          init = () => {
            let ponnents = 4
            perG             = 200
            perSp            = 2 * (2**.5/2)
            camSelected      = 0
            AIFreq           = 1/60 * 0
            flashNotices     = []
            maxPlayerLength  = 500
            showOverview     = true
            showLeaderboard  = true
            paused           = false
            AIOpponents      = ponnents
            AITurnInterval   = 1/60 * 10
            cl               = 36
            br               = 36
            rw               = 1
            playerMaxSpeed   = 2
            playerMinSpeed   = .05
            iPv              = Math.min(playerMaxSpeed, playerMinSpeed * 2)
            sp               = 1.333
            keyTimerInterval = .25
            views            = 3
            view             = 1
            keep             = [8, 11]
            mofx = mofy      = 0
            tmofx = tmofy    = 0
            scl1             = view<=1?.5:1
            scl2             = (view>=1?.4:.66)/(.5 + iPv * 2)
            tscl1            = scl1
            tscl2            = scl2
            viewFrame        = subDividedCube(1, 1, 0).filter((v, i)=>keep.filter(q=>q==i).length).map(v=>{
              s__ = 2.73
              v.map(q=>{
                q[0] *= 16*s__
                q[1] *= 18*s__
                q[2] *= 0
                q[1] += 4.5*s__
              })
              return v
            })
            if(typeof players == 'undefined'){
              players = []
              for(let m=0; m<AIOpponents+1;m++) players = [...players, spawnPlayer(m)]
            }
            iViewFrame = structuredClone(viewFrame)
          }
          init()
          
          sparks = []
          iSparkv = .125
          spawnSparks = (X, Y, Z, player) => {
            for(let m=300;m--;){
              v = Rn() ** 1 * iSparkv
              vx = S(player.theta) * player.speed / 6 + S(p=Math.PI*2*Rn()**.5) * S(q = Rn() < .5 ? Math.PI / 2 * Rn() ** .5 : Math.PI - Math.PI / 2 * Rn() ** .5) * v
              vy = C(q) * v /4
              vz = C(player.theta) * player.speed / 6 + C(p) * S(q) * v
              sparks = [...sparks, [X, Y, Z, vx, vy, vz, .5+Rn()/2]]
            }
          }
          
          accel = player => {
            if(player.alive){
              player.speed += .075
              player.speed = Math.min(playerMaxSpeed, player.speed)
            }
          }
          
          deccel = player => {
            if(player.alive){
              player.speed -= .1
              player.speed = Math.max(playerMinSpeed, player.speed)
            }
          }
          
          turnLeft = (player, testing=false) => {
            player.theta -= Math.PI/2
            if(!player.alive || testing) return
            player.path = [...player.path , [player.X, player.Y, player.Z]]
            vx = S(player.theta) * player.speed
            vy = 0
            vz = C(player.theta) * player.speed
            player.X += vx
            player.Y += vy
            player.Z += vz
            player.path[player.path.length-1] = [player.X, player.Y, player.Z]
            if((l=checkPath(player)) && player.alive) killPlayer(player, l)
          }
          
          turnRight = (player, testing=false) => {
            player.theta += Math.PI/2
            if(!player.alive || testing) return
            player.path = [...player.path , [player.X, player.Y, player.Z]]
            vx = S(player.theta) * player.speed
            vy = 0
            vz = C(player.theta) * player.speed
            player.X += vx
            player.Y += vy
            player.Z += vz
            player.path[player.path.length-1] = [player.X, player.Y, player.Z]
            if((l=checkPath(player)) && player.alive) killPlayer(player, l)
          }
          
          window.onkeydown = e => {
            console.log(e.keyCode)
            players[0].keys[e.keyCode] = true
          }
          window.onkeyup = e => {
            players[0].keys[e.keyCode] = false
            players[0].keyTimers[e.keyCode] = 0
          }
          
          window.onload = () => c.focus()

          resetGame = () => {
            players[0] = spawnPlayer(0)
          }

          doKeys = player => {
            player.keys.map((v, i) => {
              if(v && player.keyTimers[i] <= t) {
                player.keyTimers[i] = t + keyTimerInterval
                switch(i){
                  case 80: paused = !paused; break
                  case 76: showLeaderboard = !showLeaderboard; break
                  case 79: showOverview = !showOverview; break
                  case 32: if(!player.alive) resetGame(); break
                  case 37: if(!paused) turnLeft(player); break
                  case 38: if(!paused) accel(player); break
                  case 39: if(!paused) turnRight(player); break
                  case 40: if(!paused) deccel(player); break
                  case 86:
                    toggleView()
                  break;
                }
              }
            })
          }
          
          base_shp = subDividedCube(sp, 0, 0).filter((v, i)=> i==1).map(v => {
            v.map(q=>{
              q[1] *=0
            })
            return v
          })
          
          shapes = Array(cl*rw*br).fill().map((v, i) => {
            X = ((i%cl) - cl/2 + .5) * sp
            Y = (((i/cl|0)%rw) - rw/2 + .5) * sp
            Z = ((i/rw/cl|0) - br/2 + .5) * sp
            shp = structuredClone(base_shp)
            return [X, Y, Z, shp]
          })
          
          drawSparks = () => {
            sparks = sparks.filter(v=>v[6]>0)
            for(let m=view==1?2:1;m--;) {
              cond = view !== 2 && !m
              sparks.map(v => {
                omit = false
                if(!m){
                  v[0] += v[3]
                  v[1] += v[4]
                  v[2] += v[5]
                }
                X = v[0]
                Y = cond ? 0 : v[1]
                Z = v[2]
                if(cond){
                  R(Rl, -Math.PI/2, Yw, 0)
                  Z += 8
                }else{
                  R(Rl, Pt, Yw, 1)
                }
                l = cond? Q3() : Q2()
                if(view == 1){
                  if(m){
                    if(l[0] > c.width/2) omit = true
                    l[0] = Math.min(c.width/2, l[0])
                  }else{
                    if(l[0] < c.width/2) omit = true
                    l[0] = Math.max(c.width/2, l[0])
                  }
                }
                if(!omit && Z>0){
                  s = Math.min(1e4, 1200/Z*v[6])
                  x.fillStyle = '#ff000006'
                  x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
                  s/=3
                  x.fillStyle = '#ff880012'
                  x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
                  s/=3
                  x.fillStyle = '#ffffffff'
                  x.fillRect(l[0]-s/2,l[1]-s/2,s,s)
                }
                if(!m) v[6] -=.0025
              })
            }
          }
          
          AILookAhead = 1 + iPv * 10
          doAI = player => {
            if(player.AITimer <= t){
              player.AITimer = t + AIFreq
              if(Rn()<.01) (Rn()<.4 ? accel : deccel)(player)
              tplayer = structuredClone(player)
              vx = S(tplayer.theta) * tplayer.speed
              vy = 0
              vz = C(tplayer.theta) * tplayer.speed
              d = Math.hypot(vx,vy,vz)
              vx /= d
              vy /= d
              vz /= d
              vx *= AILookAhead
              vy *= AILookAhead
              vz *= AILookAhead
              l=tplayer.path.length-1
              tplayer.path[l][0] += vx
              tplayer.path[l][1] += vy
              tplayer.path[l][2] += vz
              if(checkPath(tplayer)){
                if(Rn()<.5){
                  turnRight(tplayer, true)
                  vx = S(tplayer.theta) * tplayer.speed
                  vy = 0
                  vz = C(tplayer.theta) * tplayer.speed
                  d = Math.hypot(vx,vy,vz)
                  vx /= d
                  vy /= d
                  vz /= d
                  vx *= AILookAhead
                  vy *= AILookAhead
                  vz *= AILookAhead
                  if(checkPath(tplayer,vx,vy,vz)){
                    turnLeft(player)
                  }else{
                    turnRight(player)
                  }
                }else{
                  turnLeft(tplayer, true)
                  vx = S(tplayer.theta) * tplayer.speed
                  vy = 0
                  vz = C(tplayer.theta) * tplayer.speed
                  d = Math.hypot(vx,vy,vz)
                  vx /= d
                  vy /= d
                  vz /= d
                  vx *= AILookAhead
                  vy *= AILookAhead
                  vz *= AILookAhead
                  if(checkPath(tplayer,vx,vy,vz)){
                    turnRight(player)
                  }else{
                    turnLeft(player)
                  }
                }
              }else{
                if(1 && Rn()<.0025 && player.AITurnTimer <= t){
                  player.AITurnTimer = t + AITurnInterval
                  if(Rn()<.5){
                    turnRight(tplayer, true)
                    if(!checkPath(tplayer)) turnRight(player)
                  }else{
                    turnLeft(tplayer, true)
                    if(!checkPath(tplayer)) turnLeft(player)
                  }
                }
              }
            }
          }
          
          killPlayer = (player, l) => {
            if(!player.alive) return
            spawnSparks(l1[0], 0, l1[1], player)
            player.alive = false
            player.speed = playerMinSpeed
            l2 = player.path.length-1
            player.X = l1[0]
            player.Y = 0
            player.Z = l1[1]
            player.path[l2][0] = l1[0]
            player.path[l2][1] = 0
            player.path[l2][2] = l1[1]
            if(typeof l[2] === 'number' && player.id != l[2] && players[l[2]].alive){
              players[l[2]].score++
              spawnFlashNotice(`POINT!, ${players[l[2]].name}`, `hsla(${360/players.length*l[2] + 90},99%,50%,1)`)
            }
          }
          
          drawPlayers = () => {
            for(m=view==1?2:1;m--;) {
              cond = view !== 2 && !m
              players.map((player, idx) => {
                player.path = player.path.filter((v, i) => player.path.length < maxPlayerLength|| i)
                player.path.map((q, j) => {
                  if(j){
                    omit = false
                    x.beginPath()
                    l1 = j
                    l2 = j-1
                    X1 = X = player.path[l1][0]
                    Y1 = Y = cond ? 0 : player.path[l1][1]
                    Z1 = Z = player.path[l1][2]
                    if((d1 = Math.hypot(X-players[camSelected].X, Z-players[camSelected].Z)) < 50){
                      if(cond){
                        R(Rl, -Math.PI/2, Yw, 0)
                        Z += 8
                      }else{
                        R(Rl, Pt, Yw, 1)
                      }
                      l = cond? Q3() : Q2()
                      if(view == 1){
                        if(m){
                          if(l[0] > c.width/2+300) omit = true
                          l[0] = Math.min(c.width/2, l[0])
                        }else{
                          if(l[0] < c.width/2) omit = true
                          l[0] = Math.max(c.width/2, l[0])
                        }
                      }
                      if(Z>0) x.lineTo(...l)
                      if(!omit){
                        X2 = X = player.path[l2][0]
                        Y2 = Y = cond ? 0 : player.path[l2][1]
                        Z2 = Z = player.path[l2][2]
                        if(cond){
                          R(Rl, -Math.PI/2, Yw, 0)
                          Z += 8
                        }else{
                          R(Rl, Pt, Yw, 1)
                        }
                        l = cond? Q3() : Q2()
                        if(view == 1){
                          if(m){
                            if(l[0] > c.width/2+300) omit = true
                            l[0] = Math.min(c.width/2, l[0])
                          }else{
                            l[0] = Math.max(c.width/2, l[0])
                          }
                        }
                        if(Z>0) x.lineTo(...l)
                        if(cond){
                          col1 = player.alive ? `hsla(${360/players.length*idx + 90},99%,50%,${1 / (1+d1**10/1e14)})` : `hsla(${360/players.length*idx + 90},0%,50%,${1 / (1+d1**10/1e14)})`
                          col2 = ''
                          if(!omit) stroke(col1, col2, 2, true)
                        }else{
                          if(!omit){
                            X = X2
                            Y = Y2-1
                            Z = Z2
                            R(Rl, Pt, Yw, 1)
                            l = Q2()
                            if(view == 1){
                              if(m){
                                if(l[0] > c.width/2+300) omit = true
                                l[0] = Math.min(c.width/2, l[0])
                              }else{
                                l[0] = Math.max(c.width/2, l[0])
                              }
                            }
                            if(Z>0) x.lineTo(...l)
                            if(!omit){
                              X = X1
                              Y = Y1-1
                              Z = Z1
                              R(Rl, Pt, Yw, 1)
                              l = Q2()
                              if(view == 1){
                                if(m){
                                  if(l[0] > c.width/2+300) omit = true
                                  l[0] = Math.min(c.width/2, l[0])
                                }else{
                                  l[0] = Math.max(c.width/2, l[0])
                                }
                              }
                              if(Z>0) x.lineTo(...l)
                          
                              col1 = ``
                              col2 = player.alive ? `hsla(${360/players.length*idx + 90},99%,50%,${.5 / (1+d1**10/1e14)})` : `hsla(${360/players.length*idx + 90},0%,50%,${.5 / (1+d1**10/1e14)})`
                              if(!omit) stroke(col1, col2, cond ? 2 : 1, true)
                            }
                          }
                        }
                      }
                    }
                  }
                })
                if(player.alive && !paused){
                  if(!m){
                    vx = S(player.theta) * player.speed
                    vy = 0
                    vz = C(player.theta) * player.speed
                    tplayer = structuredClone(player)
                    tplayer.X += vx
                    tplayer.Y += vy
                    tplayer.Z += vz
                    
                    if(l1 = checkPath(tplayer)){
                      if(player.alive) killPlayer(player, l1)
                    }else{
                      X = player.X += vx
                      Y = player.Y += vy
                      Z = player.Z += vz
                      if(X > perSp * perG / 2 || X < -perSp * perG/2 ||
                         Z > perSp * perG / 2 || Z < -perSp * perG/2) killPlayer(player, [player.X, player.Z])
                      if(!((t*60|0)%((20/(1+player.speed*20))|0))){
                        player.path = [...player.path, [X,Y,Z]]
                      }else{
                        player.path[player.path.length-1][0] = X
                        player.path[player.path.length-1][1] = Y
                        player.path[player.path.length-1][2] = Z
                      }
                    }
                  }
                }
                if(!idx && !player.alive){
                  x.fillStyle = '#18000688'
                  x.fillRect(0,0,c.width,c.height)
                  x.font = (fs = 100) + 'px monospace'
                  x.fillStyle = '#f02'
                  x.strokeStyle = '#000'
                  x.lineWidth = 16
                  x.strokeText('ded',c.width/2,c.height/2 - fs * 1)
                  x.fillText('ded',c.width/2,c.height/2 - fs * 1)
                  x.strokeText('hit the space key',c.width/2,c.height/2 + fs * 1)
                  x.fillText('hit the space key',c.width/2,c.height/2 + fs * 1)
                }
              })
            }
          }
          
          drawBoards = () => {
            for(m=view==1?2:1;m--;) {
              cond = view !== 2 && !m
              if(cond){
                if(view !== 2) {
                  viewFrame.map((v, i) =>{
                    if(i==0){
                      x.beginPath()
                      v.map((q, j) => {
                        X = iViewFrame[i][j][0]
                        Y = iViewFrame[i][j][1]
                        Z = iViewFrame[i][j][2]
                        Z += 8
                        if(Z>0) x.lineTo(...Q())
                      })
                      col1 = ``
                      col2 = '#000'
                      stroke(col1, col2,5, true)
                    }
                  })
                }
              }
              shapes.map((shape, idx) => {
                nx = 1+Math.round((idx%cl)/sp*2)
                ny = 1+Math.round((idx/cl|0)/sp*2)
                cnd = (nx%3 && ny%3)
                if(cnd){
                  tx = shape[0]
                  ty = shape[1]
                  tz = shape[2]
                  while(tx-players[camSelected].X > cl*sp/2) tx -= cl * sp
                  while(tx-players[camSelected].X < -cl*sp/2) tx += cl * sp
                  while(tz-players[camSelected].Z > br*sp/2) tz -= br * sp
                  while(tz-players[camSelected].Z < -br*sp/2) tz += br * sp
                  shape[3].map((v, i) => {
                    x.beginPath()
                    v.map(q=>{
                      X = q[0] + tx
                      Y = cond ? 0 : q[1] + ty
                      Z = q[2] + tz
                      if(cond){
                        R(Rl, -Math.PI/2, Yw, 0)
                        Z += 8
                      }else{
                        R(Rl, Pt, Yw, 1)
                      }
                      l = cond? Q3() : Q2()
                      if(view == 1 && !m) l[0] = Math.max(c.width/2, l[0])
                      if(Z>0) x.lineTo(...l)
                    })
                    col1 = ''
                    col2 = (idx + (idx/br|0)%4) % 4 ? '#4400ff20' : '#00ff8820'
                    oga = 1 / (1+Math.hypot(tx - players[camSelected].X, tz - players[camSelected].Z)**8/1e10)
                    stroke(col1, col2, 4, false, oga)
                  })
                }
              })
              
              perimeter.map(v=>{
                tx = v[0]
                ty = v[1]
                tz = v[2]
                if((d1=Math.hypot(tx-players[camSelected].X,tz-players[camSelected].Z)) < 50){
                  oga = 1 / (1+d1**10/1e14)
                  if(oga > .025){
                    v[3].map(q => {
                      x.beginPath()
                      q.map(n => {
                        X = tx + n[0]
                        Y = cond ? 0 : ty + n[1]
                        Z = tz + n[2]
                        if(cond){
                          R(Rl, -Math.PI/2, Yw, 0)
                          Z += 8
                        }else{
                          R(Rl, Pt, Yw, 1)
                        }
                        l = cond? Q3() : Q2()
                        if(view == 1 && !m) l[0] = Math.max(c.width/2, l[0])
                        if(Z>0) x.lineTo(...l)
                      })
                      col1 = view !== 2 && !m ? '#888' : ''
                      col2 = '#888'
                      stroke(col1, col2, 4, false, oga)
                    })
                  }
                }
              })
              x.globalAlpha = 1
            }
          }
          mofx1 = mofy1 = mofx2 = mofy2 = 0
          oXv = -players[camSelected].X
          oX = oXv
          oYv = -players[camSelected].Y
          oY = oYv
          oZv = -players[camSelected].Z
          oZ = oZv
          
          base_peri_shp = []
          perimeter     = []
          for(i=4;i--;){
            X = S(p=Math.PI*2/4*i+Math.PI/4)
            Y = C(p)
            Z = 0
            a = [...a, [X, Y, Z]]
          }
          base_peri_shp = [...base_peri_shp, a]
          b = []
          for(i=perG; i--;){
            tx = (i-perG/2 + .5) * perSp
            ty = 0
            tz = perG/2 * perSp
            shp = structuredClone(base_peri_shp)
            b = [...b, [tx, ty, tz, shp]]
          }
          perimeter = [...perimeter, ...b]
          for(i=3;i--;){
            e = structuredClone(b)
            e.map(v=>{
              X = v[0]
              Y = v[1]
              Z = v[2]
              R(0,0,Math.PI*2/4*(i+1))
              v[0] = X
              v[1] = Y
              v[2] = Z
              v[3].map(q => {
                q.map(n=>{
                  X = n[0]
                  Y = n[1]
                  Z = n[2]
                  R(0,0,Math.PI*2/4*(i+1))
                  n[0] = X
                  n[1] = Y
                  n[2] = Z
                })
              })
            })
            perimeter = [...perimeter, ...e]
          }
          perimeter.map(v=>{
            v[3].map(q=>{
              q.map(n=>{
                n[1] *= 2
                n[0]
                n[1] -= perSp * 1
                n[2]
              })
            })
          })
        }

        x.globalAlpha = 1
        x.fillStyle   = `#000e`
        x.fillRect(0,0,c.width,c.height)
        x.lineJoin    = x.lineCap = 'butt'

        boardHoming = 10
        
        if((l=players[camSelected].path.length)){
          el = players[camSelected].path[l-1]
          for(let m=2;m--;){
            X = el[0]
            Y = m ? 0 : el[1]
            Z = el[2]
            if(m){
              R(Rl, -Math.PI/2, Yw, 0)
              Z += 8
              l2 = Q3p()
              mofx2 = -l2[0]/1
              mofy2 = -l2[1]/1
            }else if(0){
              R(Rl, Pt, Yw, 1)
              l2 = Q2p()
              mofx1 = -l2[0]/1
              mofy1 = -l2[1]/1
            }
          }
        }

        min = (.2+players[camSelected].speed) * 1.1
        
        oXv = -players[camSelected].X
        oYv = -players[camSelected].Y
        oZv = -players[camSelected].Z
        oXv2 =  .2
        oYv2 = view == 2 ? 0 :0
        oZv2 = view == 2 ? 8 :0
        
        vx = (oXv-oX) / boardHoming
        vy = (oYv-oY) / boardHoming
        vz = (oZv-oZ) / boardHoming
        d1 = Math.hypot(vx, vy, vz) + .0001
        d2 = Math.min(d1, min)
        vx /= d1
        vy /= d1
        vz /= d1
        vx *= d2
        vy *= d2
        vz *= d2
        oX += vx
        oY += vy
        oZ += vz

        Rlv = 0
        
        min = .05
        v = (Rlv-Rl) / boardHoming
        d1 = Math.abs(v) + .0001
        d2 = Math.min(d1, min)
        v/=d1
        v*=d2
        Rl += v
        
        Ptv  = -.5
        v = (Ptv-Pt) / boardHoming
        d1 = Math.abs(v) + .0001
        d2 = Math.min(d1, min)
        v/=d1
        v*=d2
        Pt += v

        Ywv  = -players[camSelected].theta
        v = (Ywv-Yw) / boardHoming
        d1 = Math.abs(v) + .0001
        d2 = Math.min(d1, min)
        v/=d1
        v*=d2
        Yw += v
        
        players.map(player => {
          doKeys(player)
        })
        
        homing = 5
        viewFrame.map((v, i) => {
          x.beginPath()
          v.map((q, j) => {
            
            switch(view){
              case 0:
                s_ = i ? 0 : 2
                ofx = -8 * s__
                break
              case 1:
                s_ = i ? 1 : 1
                ofx = 0
                break
              case 2:
                s_ = i ? 2 : 0
                ofx = 8 * s__
                break
            }
            X1 = q[0] * s_ + ofx
            Y1 = q[1]
            Z1 = q[2]
            
            X2 = iViewFrame[i][j][0]
            Y2 = iViewFrame[i][j][1]
            Z2 = iViewFrame[i][j][2]
            vx = X1 - X2
            vy = Y1 - Y2
            vz = Z1 - Z2
            d1 = Math.hypot(vx, vy, vz) + .001
            d2 = Math.min(d1, homing)
            vx /= d1
            vy /= d1
            vz /= d1
            vx *= d2
            vy *= d2
            vz *= d2
            X = iViewFrame[i][j][0] += vx
            Y = iViewFrame[i][j][1] += vy
            Z = iViewFrame[i][j][2] += vz
            Z += 8
            if(Z>0) x.lineTo(...Q())
          })
          col1 = `#0f8`
          col2 = ''
          stroke(col1, col2,2, false)
        })
        
        mofx          = iViewFrame[1][0][0]
        mofy          = 0
        
        drawBoards()
        
        x.strokeStyle = `#fff4`
        X1            = mofx*40-60
        Y1            = 0
        X2            = 120
        Y2            = 50
        x.lineWidth   = 10
        x.font        = (40) + 'px monospace'
        x.textAlign   = 'center'
        for(m=3; m--; ){
          lx = 875 * (m-1)
          x.strokeRect(960 + X1 + lx, 20 + Y1, X2, Y2)
          x.fillStyle   = `#000`
          x.fillRect(960 + X1 + lx, 20 + Y1, X2, Y2)
          switch(m){
            case 0: str = '3D'; break
            case 1: str = '←v→'; break
            case 2: str = '2D'; break
          }
          x.fillStyle   = `#fff`
          x.fillText(str, 960 + X1 + 60 + lx, 56)
        }

        scl1   = view<=1?.25:.5
        scl2   = (view>=1?.4:.66)/2
        tmofx += (mofx - tmofx) / 10
        tmofy += (mofy - tmofy) / 10
        tscl1  += (scl1 - tscl1) / 20
        tscl2  += (scl2 - tscl2) / 20

        players.map((player, idx) => {
          if(idx && !player.alive){
            if(!player.respawnPending){
              player.respawnPending = true
              setTimeout(()=>{
                players[idx] = spawnPlayer(idx)
              }, 2000)
            }
          }else{
            if(!paused && idx && player.alive) doAI(player)
          }
        })

        drawSparks()
        drawPlayers()
        
        if(showOverview) drawOverview()
        if(showLeaderboard) drawLeaderboard()

        flashNotices = flashNotices.filter(v=>v[2]>0)
        if(flashNotices.length){
          x.fillStyle = flashNotices[l=flashNotices.length-1][1]
          x.globalAlpha = Math.min(1, flashNotices[l][2])
          x.textAlign = 'center'
          x.fillRect(0,0,c.width,c.height)
          x.fillStyle = '#fff8'
          x.font = (fs=100)+'px monospace'
          x.strokeStyle = '#000a'
          x.lineWidth = 10
          x.strokeText(flashNotices[l][0],c.width/2, c.height/2+fs/4)
          x.fillText(flashNotices[l][0],c.width/2, c.height/2+fs/4)
          flashNotices[l][2]-=.05
        }
        x.globalAlpha = 1

        x.strokeStyle = `#fff4`
        X2            = paused ? 280 : 240
        Y2            = 50
        X1            = -X2/2
        Y1            = c.height - Y2 - 10
        x.lineWidth   = 10
        x.font        = (40) + 'px monospace'
        x.textAlign   = 'center'
        x.strokeRect(960 + X1, Y1, X2, Y2)
        x.fillStyle   = paused ? '#601' : '#021'
        x.fillRect(960 + X1, Y1, X2, Y2)
        str = paused ? 'unpause [p]' : ' pause [p] '
        x.fillStyle   = `#fff`
        x.fillText(str, 960, Y1 + 33)

        t+=1/60
        requestAnimationFrame(Draw)
      }
      Draw()
    </script>
  </body>
</html>